# AGENT.md — MVP Crypto Direction Forecast (BYBIT SPOT BTCUSDT)

Этот файл — **источник истины** для coding-agent (Codex CLI).  
Перед любыми изменениями в коде **прочитай этот файл целиком** и следуй ему как ТЗ.  
Если в репозитории есть конфликты между AGENT.md и README/комментами — **приоритет у AGENT.md**.

---

## 0) Неподлежащие обсуждению правила (Hard Constraints)

### 0.1. Без торговли
- **Никаких ордеров, аккаунтов, ключей, приватных эндпоинтов.**
- Только публичные рыночные данные (REST/WS).

### 0.2. GPU-only
- **Любое обучение и тестирование ML/RL — строго на GPU (CUDA).**
- Если CUDA недоступна: **скрипт/тест обязан завершаться ошибкой** с понятным текстом:
  - что именно требует GPU,
  - как проверить CUDA в PyTorch.

### 0.3. Две разные модели (строго)
- **Model_1_UP** — отдельный экземпляр, отдельные веса, отдельные чекпойнты, отдельные логи.
- **Model_2_DOWN** — полностью отдельная модель и пайплайн (но может использовать общие модули).
- Это НЕ “одна модель с двумя классами”. Это **две разные**.

### 0.4. HOLD/FLAT допустим, но нежелателен
- HOLD/FLAT можно использовать как аварийное действие/состояние,
- но нужно **минимизировать**:
  - через штраф `R_hold` в RL,
  - через decision rule/threshold и явные метрики (`hold_rate`).

### 0.5. В каждом тесте/прогоне должны быть визуализации
Любой тест/скрипт/эксперимент должен сохранять графики в `reports/...`:
- графики по эпохам/итерациям/эпизодам (если есть),
- **средняя полоса** (mean band) обязательно:
  - линия скользящего среднего (moving average),
  - и полоса вокруг: `mean ± std` (скользящий std) **или** `mean ± std` по нескольким прогонам,
- строгие подписи:
  - `Title`,
  - подписи осей `X label / Y label`,
  - `Legend`,
  - для матриц/heatmap: подписи осей + тики классов (например `True/Pred`),
- никакого GUI:
  - Matplotlib backend **Agg**,
  - сохранять в PNG (и опционально SVG).

---

## 1) Цель MVP (что именно делаем)

Собрать MVP для прогнозирования направления на BYBIT SPOT `BTCUSDT`, который включает:

1) **Проверку единообразия данных** между BYBIT WebSocket и REST (Kline, 1m).  
2) **Замороженный исторический датасет** на одном фиксированном периоде (REST kline).  
3) **Baseline supervised** (две модели: UP и DOWN), GPU-only, с метриками и визуализациями по эпохам.  
4) **RL прототип** (две модели: UP и DOWN), reward за угадывание направления, штраф за HOLD, GPU-only, с визуализациями по эпизодам/итерациям.  
5) Отдельный тест **“reward/penalty → веса”**: показать через логи/графики, как награды/штрафы влияют на градиенты и обновление весов.

---

## 2) BYBIT V5: какие данные используем и как

> В коде держи endpoints как константы в одном месте (например `src/cryptomvp/bybit/constants.py`).

Используем **BYBIT V5** для SPOT:

```text
WS public spot endpoint:
- wss://stream.bybit.com/v5/public/spot

WS topic (kline):
- "kline.{interval}.{symbol}"
- Используй только закрытые свечи: data[].confirm == true

REST kline:
- GET /v5/market/kline?category=spot&symbol=BTCUSDT&interval=1&start=...&end=...&limit=...

(Опционально для отладки)
REST recent trades:
- GET /v5/market/recent-trade?category=spot&symbol=BTCUSDT&limit=...
